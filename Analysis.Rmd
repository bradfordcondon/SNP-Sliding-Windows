---
title: "Tiling"
author: "Bradford Condon"
date: "October 20, 2016"
output:
  html_document:
    toc: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Overview

Goal:

Categorize recombination within the genome.

We want to identify SNP-dense regions that are (high SNP within-clade) and (low SNP out-clade).

To do this, I will either use the shell of my sliding window script in perl, or write a new function in R.

Once windows are identified, I want to plot them on the scaffolds, **colored by strain**.

Note: FLTB refers to Festuca,Lolium, Triticum, Bromus.  Any strains grouping in *either* of the wheat blast clades are placed in the FLTB clade for this analysis.  This is desireable for looking for recombination events/ regions that are most similar to non-wheat blast isolates.

##Source data

the loadData.R script reads in SNP report sheets generated by the SNP-finder algorithm developed by Dr. Mark Farman.  This currently points at directories on my local machine and will need to be modified for use elsewhere (and for new SNP reports).


```{r}
#load dependencies etc
library(plyr)
library(ggplot2)
library(knitr)
library(dplyr)
source("R/helperFunctions.R")
```


```{r, eval=TRUE}
#load image created by LoadData.R
load("IA1andBR80ReadSNPs.RDATA")
```


##Summarizing scaffolds
First, let's summarize scaffolds based on SNPs by clade.  This will allow me to develop the sorts of methods I'll use once windows are defined

```{r}
#first, sum number of SNPs for each file for each scaffold
snpsGrouped <- summarise(group_by(br80AllSnpDF, scaffoldRef, fileName, Clade), SNPs = n())
#now, take the average for each scaffold
snpsAvg <- summarise(group_by(snpsGrouped, fileName), average = mean(SNPs), SD = sd(SNPs))
kable(snpsAvg)
#Plot this in whiskerplot form

ggplot(snpsGrouped, aes(x= fileName, y = SNPs, fill= Clade)) + geom_boxplot()
#digitaria skews the plot too much: remove

snpsGrouped2 <- filter(snpsGrouped, Clade != 'digitaria')
ggplot(snpsGrouped2, aes(x= fileName, y = SNPs, fill= Clade)) + geom_boxplot()+ scale_y_log10()+ggtitle("Number of SNPs/scaffold")+ ylab("number of SNPs (log)") +  theme(axis.text.x = element_text(angle = 60, hjust = 1)) + xlab("")

```

We can see that the FLTB isolates have lower SNPs/scaffold.  Overall this plot isn't that informative because it isn't scaled by scaffold size.
We can transform the number of SNPs into SNPs/kb.

```{r}
#change to character, merge
br80lengths$scaffoldRef<- as.character(br80lengths$scaffold)
snpsGrouped2$scaffoldRef<- as.character(snpsGrouped2$scaffoldRef)
total <- merge(br80lengths,snpsGrouped2,by="scaffoldRef")

totalPercent<- mutate(total, scaledSNPs = SNPs * 100/ ( as.numeric(length))) 
ggplot(totalPercent, aes(x= fileName, y = scaledSNPs, fill= Clade)) + geom_boxplot()+ggtitle("Percent divergence of scaffolds")+ ylab("Percent divergence (SNPs*100/scaffoldlength") +  theme(axis.text.x = element_text(angle = 60, hjust = 1)) + xlab("")+scale_y_continuous(limits = c(0, 10))


totalPercent<- group_by(totalPercent, Clade)
statsByClade<- summarise(totalPercent, meanSNPs = mean(scaledSNPs), SD = sd(scaledSNPs), medianSNPs = median(scaledSNPs))

kable(statsByClade)

```

What's interesting is that the general scaffold-by-scaffold % SNPs isn't *hugely* variable.  The mean is universally lower for FLTB, but 0.5% as opposed to 0.6-1.0%.  However, the shape of the data shows that the median for FLTB is 0.04 as opposed to 0.27-0.59.   


##Definding windows
Next- we want to create windows, and score those windows based on number of SNPs by clade.  In particular, we want to know

* Max SNPs/window/clade
* Min SNPs/window/clade
* Clade which had min SNP value?

This is done in the createSlidingWindows.R script.

#Analyzing sliding windows
To help with scoring the sliding windows, we need to ask some basic questions about them.

* What is the distribution of number of SNPs per window for each clade?

```{r}
#load sliding windows
load("br80Windows_v3_1kb.robj")

snpsGrouped <- summarise(group_by(br80WindowsDF, Scaffold, fileName, Clade), avgSNPs = mean(count))

ggplot(data = snpsGrouped, aes(x=fileName, y = avgSNPs, fill = Clade))+ geom_boxplot()+ theme(axis.text.x = element_text(angle = 60, hjust = 1)) +ggtitle("Br80, average number of SNPs 1kb/window")

ggplot(data = snpsGrouped, aes(x=avgSNPs))+ geom_histogram()+ggtitle("Br80 reference, log(average number of SNPs) 1kb/window")+facet_wrap(~Clade, nrow = 3)+scale_y_log10()

#just wheat blast

FLTBgrouped <- group_by(filter(br80WindowsDF, Clade == 'FLTB' ), Scaffold, fileName, Window)

ggplot(data = FLTBgrouped, aes(x=fileName, y = count))+geom_boxplot()+ theme(axis.text.x = element_text(angle = 60, hjust = 1)) +ggtitle("Br80, average number of SNPs 1kb/window, FLTB only")

ggplot(data = FLTBgrouped, aes(x=count))+ geom_histogram()+ggtitle("Br80 reference, SNPs/1kb window")+facet_wrap(~fileName, nrow = 3)+scale_x_continuous(limits= c(0, 75))
#note- the above plot doesn't account for windows with n SNPs = 0.

```

This demonstrates that setting min SNPs = 25 (2.5% divergence) for a given *taxon* will seperate the vast majority of windows

#scoring sliding windows

Critical!  Right now the script does the following *for each window region*:

* 1) Windows with 0 FLTB snps are set as being FLTB origin.
* 2) Windows without FLTB/non-FLTB SNPS are ignored.
* 3) Windows are classified based on the FLTB/non-FLTB score.
  * the *AVERAGE* FLTB is compared with the *MINIMUM* non-FLTB.
  * Whichever of the two is lower is considered the source for that window.


Possible big change to make: There is no minimum number of SNPs to consider a scaffold.  If we're interested in SNP-dense regions, want to set some sort of minimum.  But compared to which strains/clades?  All of them?  Just FLTB?

(Need minimum number of SNPs in wheat BLAST)

Issue: sometimes, clades are tied for minimum.  IE brachiara and Oryza will both have only 1 SNP.  what then?

```{R, eval=FALSE}
allScaffoldsTracker<- br80WindowsDF
#let's classify each window as being "outsourced or not".
#I'm going to do define this as a minimum "out" distance being LESS than the average "in" distance
#Final out is going to be
#scaffold - window pos - in/out - number of snps


```



#Plotting windows

```{r, eval=FALSE}

#Convert window character to numeric
dfTracker$window<- as.numeric(gsub( "-.*", "", x= as.character(dfTracker$window)))
##Loop through every scaffold, print to a PDF.
scaffoldList <- as.character((unique(dfTracker$Scaffold)))
pdf("br80_5kwindows.pdf", 8.5, 11)
for (i in scaffoldList){
scaffToPlot<- subset(dfTracker, Scaffold == i)
title <- paste("br80", i)
p<- ggplot(scaffToPlot, aes(x=window, fill = match)) +  ggtitle(title)+xlab("Br80 position")+ geom_histogram() 
plot(p)
}
dev.off()
```

